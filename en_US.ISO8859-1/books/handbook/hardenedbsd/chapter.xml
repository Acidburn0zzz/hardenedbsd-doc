<?xml version="1.0" encoding="iso-8859-1"?>

<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="hardenedbsd">
	<info>
		<title>HardenedBSD</title>

		<authorgroup>
			<author>
				<personname>
					<firstname>Shawn</firstname>
					<surname>Webb</surname>
				</personname>
				<contrib>Written by </contrib>
			</author>
		</authorgroup>
	</info>

	<sect1 xml:id="hardenedbsd-synopsis">
		<title>Synopsis</title>
		<indexterm>
			<primary>HardenedBSD</primary>
		</indexterm>

		<para>HardenedBSD is a fork of FreeBSD, founded
		    in 2014, that implements exploit mitigations and
		    security hardening technologies. The primary goal
		    of HardenedBSD is to port over the grsecurity
		    patchset for Linux to HardenedBSD. HardenedBSD
		    takes a defense-in-depth approach to security,
		    implementing many security hardening technologies
		    out-of-the-box.
		</para>
		<para>Some of HardenedBSD's features can be toggled
		    on a per-application and per-jail basis using
		    a tool called secadm. Documentation for secadm
		    will be covered in this chapter.
		</para>
	</sect1>

	<sect1 xml:id="hardenedbsd-history">
		<title>History</title>
		<para>Work on HardenedBSD began in 2013 when Oliver
		    Pinter and Shawn Webb started working on an
		    implementation of Address Space Layout
		    Randomization (ASLR) for FreeBSD. At that time,
		    HardenedBSD was meant to be a staging area for
		    experimental development on the ASLR patch. Over
		    time, as the process of upstreaming ASLR to
		    FreeBSD became more difficult, HardenedBSD
		    naturally became a fork.
		</para>
		<para>HardenedBSD completed its ASLR implementation
		    in 2015 with the strongest form of ASLR ever
		    implemented in any of the BSDs. Since then,
		    HardenedBSD has moved on to implementing other
		    exploit mitigations and hardening technologies.
		    OPNsense, an open source firewall based on
		    FreeBSD, incorporated HardenedBSD's ASLR
		    implementation in 2016.
		</para>
		<para>HardenedBSD exists today as a fork of FreeBSD
		    that closely follows FreeBSD's source code.
		    HardenedBSD syncs with FreeBSD every six hours
		    for the following FreeBSD branches:
		</para>
		<itemizedlist>
			<listitem><para>HEAD</para></listitem>
			<listitem><para>stable/11</para></listitem>
			<listitem><para>releng/11.0</para></listitem>
			<listitem><para>stable/10</para></listitem>
		</itemizedlist>
	</sect1>
	<sect1 xml:id="hardenedbsd-features">
		<title>Features</title>
		<para>HardenedBSD has successfully implemented the
		    following features:
		</para>
		<itemizedlist>
			<listitem>
				<para>PaX-inspired Address Space
				    Layout Randomization (ASLR)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled as
				    Position-Independent Executables
				    (PIEs)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled with full RELRO
				    (RELRO + BIND_NOW)
				    </para>
			</listitem>
			<listitem>
				<para>PaX-inspired NOEXEC</para>
			</listitem>
			<listitem>
				<para>PaX-inspired ASLR bruteforce
				    protection (SEGVGUARD)
				</para>
			</listitem>
			<listitem>
				<para>Hardening of certain sensitive
				    sysctl nodes
				</para>
			</listitem>
			<listitem>
				<para>Network stack hardening</para>
			</listitem>
			<listitem>
				<para>Executable file integrity
				    enforcement</para>
			</listitem>
			<listitem>
				<para>Hardening of the boot process
				    </para>
			</listitem>
			<listitem>
				<para>procfs/linprocfs hardening</para>
			</listitem>
			<listitem>
				<para>LibreSSL as the default crypto
				    library in base</para>
			</listitem>
			<listitem>
				<para>Trusted Path Execution (TPE)</para>
			</listitem>
			<listitem>
				<para>Randomized PIDs</para>
			</listitem>
		</itemizedlist>
	</sect1>
	<sect1 xml:id="hardenedbsd-kernopts">
		<title>Generic Kernel Options</title>
		<para>All of HardenedBSD's features that rely on
		    kernel code require the following kernel option:
		    <programlisting>options	PAX</programlisting>
		    Additionally, the following kernel option is not
		    required, but exposes extra &man.sysctl.8;
		    nodes:
		    <programlisting>options	PAX_SYSCTLS</programlisting>
		</para>
		<para>Generic system hardening can be enabled with
		    the following kernel option:
		    <programlisting>options	PAX_HARDENING</programlisting>
		</para>
	</sect1>
	<sect1 xml:id="hardenedbsd-hardening">
		<title>Generic System Hardening</title>
		<sect2>
			<title>Introduction</title>
			<para>HardenedBSD implements generic system
			    hardening with the PAX_HARDENING kernel
			    option. Many of these hardening features
			    deal with restricting what non-root users
			    are permitted to do. When the kernel is
			    compiled with the PAX_HARDENING kernel
			    option, certain &man.sysctl.8; nodes are
			    modified from their defaults.
			</para>
			<para>&man.procfs.5; and &man.linprocfs.5;
			    are modified to prevent arbitrary writes
			    to a process's registers. This behavior
			    is controlled by the hardening.procfs_harden
			    &man.sysctl.8; node;
			</para>
			<para>&man.kld.4; related system calls are
			    restricted to non-jailed, root-only users.
			    Attempting to list kernel modules using
			    &man.modfind.2;, &man.kldfind.2;, and the
			    other KLD_related system calls will
			    result in permission denied if used by a
			    non-root or jailed user.
			</para>
		</sect2>
		<sect2>
			<title>Modified sysctl Nodes</title>
			<para>These are the nodes that are modified
			    from their original defaults when
			    PAX_HARDENING is enabled in the kernel:
			</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="5">
					<thead>
						<row>
							<entry>Node</entry>
							<entry>Description</entry>
							<entry>Type</entry>
							<entry>Original Value</entry>
							<entry>Hardened Value</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>kern.msgbuf_show_timestamp</entry>
							<entry>Show timestamp in msgbuf</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>kern.randompid</entry>
							<entry>Random PID modulus</entry>
							<entry>Integer</entry>
							<entry>0, read+write</entry>
							<entry>Randomly set at boot and made read-only</entry>
						</row>
						<row>
							<entry>net.inet.ip.random_id</entry>
							<entry>Assign random IP ID values</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.use_deprecated</entry>
							<entry>Allow the use of addresses whose preferred lifetimes have expired</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.use_tempaddr</entry>
							<entry>Use IPv6 temporary addresses with SLAAC</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.prefer_tempaddr</entry>
							<entry>Prefer IPv6 temporary address generated last</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.see_other_gids</entry>
							<entry>Unprivileged processes may see subjects/objects with different real gid</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.see_other_uids</entry>
							<entry>Unprivileged processes may see subjects/objects with different real uid</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.hardlink_check_gid</entry>
							<entry>Unprivileged processes cannot create hard links to files owned by other groups</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.hardlink_check_uid</entry>
							<entry>Unprivileged processes cannot create hard links to files owned by other users</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.stack_guard_page</entry>
							<entry>Insert stack guard page ahead of the growable segments</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.unprivileged_proc_debug</entry>
							<entry>Unprivileged processes may use process debugging and tracing facilities</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.unprivileged_read_msgbuf</entry>
							<entry>Unprivileged processes may read the kernel message buffer</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</sect2>
	</sect1>

	<sect1 xml:id="hardenedbsd-aslr">
		<title>Address Space Layout Randomization (ASLR)</title>
		<sect2>
			<title>Introduction</title>
			<para>ASLR randomizes the virtual address
			    space of a process through using
			    randomized deltas. ASLR prevents
			    attackers from knowing where
			    vulnerabilities lie in memory. Without
			    ASLR, attackers can easily generate and
			    reuse exploits across all deployed
			    systems. As is the case with all exploit
			    mitigation technologies, ASLR is meant
			    to help frustrate attackers, though ASLR
			    alone is not sufficient to completely
			    stop attacks. ASLR simply provides a
			    solid foundation in which to implement
			    further exploit mitigation technologies.
			    A holistic approach to security (aka,
			    defense-in-depth) is the best way to
			    secure a system. Additionally, ASLR is
			    intended and designed to help prevent
			    remote attacks, not local.
			</para>
			<para>HardenedBSD's ASLR implementation is
			    based off of PaX's design and
			    documentation. PaX's documentation can be
			    found
			    <link xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/aslr.txt">
			        here</link>.
			</para>
			<para>On 13 July 2015, HardenedBSD's ASLR
			    implementation was completed with full
			    stack and VDSO randomization. Since then,
			    various improvements have been made, like
			    implementing shared library load order
			    randomization. HardenedBSD is the only
			    BSD to support true stack randomization.
			    Meaning, the top of the stack is
			    randomized in addition to a random-sized
			    gap between the top of the stack and the
			    start of the user stack.
			</para>
			<para>ASLR is enabled by default in the
			    <filename>HARDENEDBSD</filename> kernel
			    configuration. ASLR has been tested and
			    known to work on amd64, i386, arm, arm64,
			    and risc-v. The options for ASLR are:
			    <programlisting>options	PAX
options	PAX_ASLR</programlisting>
			</para>
			<para>If the kernel has been compiled with
			    <programlisting>options	PAX_SYSCTLS</programlisting>
			    then the sysctl node security.hardening.pax.aslr.status
			    will be available. The following values
			    determine the enforcement of ASLR:
			</para>
			<itemizedlist>
				<listitem><para>0 - Force disabled
				    </para></listitem>
				<listitem><para>1 - Disabled by
				    default. User must opt
				    applications in.</para>
				</listitem>
				<listitem><para>2 - Enabled by
				    default. User must opt
				    applications out (default).</para>
			    	</listitem>
				<listitem><para>3 - Force enabled
				    </para></listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Implementation</title>
			<para>HardenedBSD's ASLR uses a set of four
			    deltas on 32-bit systems and five deltas
			    on 64-bit systems. Additionally, on
			    64-bit systems, 32-bit compatibility is
			    supported by a set of different deltas.
			    The deltas are calculated at image
			    activation (execve) time. The deltas are
			    provided as a hint to the virtual memory
			    subsystem, which may further modify the
			    hint. Such may be the case if the
			    application explicitly requests superpage
			    support or other alignment constraints.
			</para>
			<para>The deltas are:</para>
			<itemizedlist>
				<listitem><para>PIE execution base
				    </para></listitem>
				<listitem><para>mmap hint for
				    non-fixed mappings</para>
				</listitem>
				<listitem><para>stack top and gap
				    </para></listitem>
				<listitem><para>Virtual Dynamic
				    Shared Object (VDSO)</para>
				</listitem>
				<listitem><para>on 64-bit systems,
				    mmap hint for MAP_32BIT mappings
				    </para></listitem>
			</itemizedlist>
			<para> The calculation of each delta is
			    controlled by how many bits of entropy
			    the user wants to introduce into the
			    delta. The amount of entropy can be
			    overridden in the kernel config and
			    via boot-time (loader.conf) tunables. By
			    default, HardenedBSD uses the following
			    amount of entropy:
			</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="8">
					<thead>
						<row>
							<entry>Delta</entry>
							<entry>32-bit</entry>
							<entry>64-bit</entry>
							<entry>Compat</entry>
							<entry>Tunable</entry>
							<entry>Compat Tunable</entry>
							<entry>Kernel Option</entry>
							<entry>Compat Kernel Option</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>mmap</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.mmap_len</entry>
							<entry>hardening.pax.aslr.compat.mmap_len</entry>
							<entry>PAX_ASLR_DELTA_MMAP_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_MMAP_DEF_LEN</entry>
						</row>
						<row>
							<entry>Stack</entry>
							<entry>14 bits</entry>
							<entry>42 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.stack_len</entry>
							<entry>hardening.pax.aslr.compat.stack_len</entry>
							<entry>PAX_ASLR_DELTA_STACK_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_STACK_DEF_LEN</entry>
						</row>
						<row>
							<entry>PIE exec base</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.exec_len</entry>
							<entry>hardening.pax.aslr.compat.exec_len</entry>
							<entry>PAX_ASLR_DELTA_EXEC_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_EXEC_DEF_LEN</entry>
						</row>
						<row>
							<entry>VDSO</entry>
							<entry>8 bits</entry>
							<entry>28 bits</entry>
							<entry>8 bits</entry>
							<entry>hardening.pax.aslr.vdso_len</entry>
							<entry>hardening.pax.aslr.compat.vdso_len</entry>
							<entry>PAX_ASLR_DELTA_VDSO_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_VDSO_DEF_LEN</entry>
						</row>
						<row>
							<entry>MAP_32BIT</entry>
							<entry>N/A</entry>
							<entry>18 bits</entry>
							<entry>N/A</entry>
							<entry>hardening.pax.aslr.map32bit_len</entry>
							<entry>N/A</entry>
							<entry>PAX_ASLR_DELTA_MAP32BIT_DEF_LEN</entry>
							<entry>N/A</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>When a process forks, the child process
			    inherits its parent's ASLR settings,
			    including deltas. Only at image
			    activation (execve) time does a process
			    receive new deltas.
			</para>
		</sect2>
		<sect2>
			<title>Position-Independent Executables (PIEs)</title>
			<para>In order to make full use of ASLR,
			    applications must be compiled as
			    Position-Independent Executables. If an
			    application is not compiled as a PIE,
			    then ASLR will be applied to all but the
			    execution base.  All of base is compiled
			    as PIEs, with the exception of a few
			    applications that explicitly request to
			    be statically compiled. Those
			    applications are:
			</para>
			<itemizedlist>
				<listitem><para>All applications in
				    /rescue</para></listitem>
				<listitem><para>/sbin/devd</para>
				</listitem>
				<listitem><para>/sbin/init</para>
				</listitem>
				<listitem><para>/usr/sbin/nologin</para>
				</listitem>
			</itemizedlist>
			<para>Compiling all of base as PIEs can be
			    turned off by setting WITHOUT_PIE=yes in
			    &man.src.conf.5;
			</para>
		</sect2>
		<sect2>
			<title>Shared Library Load Order Randomization</title>
			<para>Breaking ASLR remotely requires
			    multiple vulnerabilities, including one
			    or more information leakage
			    vulnerabilities. Information leakage
			    vulnerabilities expose data an attacker
			    can use to determine the memory layout
			    of the process. Code reuse attacks, like
			    ROP and its variants, exist to attack
			    exploit mitigations like PAGEEXEC/NOEXEC.
			    Over the years, a lot of tooling for
			    automated ROP gadget generation has been
			    developed. The tools generally rely on
			    gadgets found via shared libraries and
			    require that those shared libraries be
			    loaded in the same order. By randomizing
			    the order in which shared libraries get
			    loaded, ROP gadgets have a higher chance
			    of failing. Shared library load order
			    randomization is disabled by default, but
			    can be opted in on a per-application
			    basis using secadm.
			</para>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-wxorx">
		<title>PAGEEXEC and MPROTECT (aka, NOEXEC)</title>
		<sect2>
			<title>Introduction</title>
			<para>PAGEEXEC and MPROTECT comprise what
			    is more commonly called W^X (W xor X).
			    The design and implementation is inspired
			    by PaX's. PAGEEXEC prevents applications
			    from creating memory mappings that are
			    both writable (W) and executable (X) at
			    &man.mmap.2; time. MPROTECT prevents
			    applications from toggling memory
			    mappings between writable and executable
			    with &man.mprotect.2;. Combining both
			    PAGEEXEC and MPROTECT prevents attackers
			    from executing injected code, thus
			    forcing attackers to utilize code reuse
			    techniques like ROP and its variants.
			    Code reuse techniques are very difficult
			    to make reliable, especially when
			    multiple exploit mitigation technologies
			    are present and active.
			</para>
			<para>PaX's documentation for these features:
				<itemizedlist>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/pageexec.txt">
					    PAGEEXEC</link></para>
			    		</listitem>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/mprotect.txt">
					    MPROTECT</link></para>
			    		</listitem>
				</itemizedlist>
			</para>
			<para>The PAGEEXEC and MPROTECT features can
			    be enabled with the following kernel
			    option, which is enabled by default in the
			    <filename>HARDENEDBSD</filename>
			    kernel:
			    <programlisting>options	PAX_NOEXEC</programlisting>
			    If the PAX_SYSCTLS option is also
			    enabled, two new sysctl nodes will be
			    created, which follow the same symantics
			    as the hardening.pax.aslr.status sysctl:
			    <itemizedlist>
				    <listitem>
					<para>hardening.pax.pageexec.status
						<itemizedlist><listitem><para>Default: 2</para></listitem></itemizedlist>
				    	</para></listitem>
				    <listitem>
					<para>hardening.pax.mprotect.status
						<itemizedlist><listitem><para>Default: 2</para></listitem></itemizedlist>
				    	</para></listitem>
			    </itemizedlist>
			</para>
		</sect2>
		<sect2>
			<title>PAGEEXEC</title>
			<para>If an application requests a memory
			    mapping via &man.mmap.2;, and the
			    application requests PROT_WRITE and
			    PROT_EXEC, then PROT_EXEC is dropped.
			    The application will be able to write to
			    the memory, but not execute what was
			    written. When an application requests W|X
			    mappings, the application is more likely
			    to simply write to the mapping, but not
			    execute it. Such is the case with certain
			    Python scripts: the developer is simply
			    asking for more permissions than is truly
			    needed.
			</para>
			<para>The kernel keeps a concept of max
			    protection. HardenedBSD drops PROT_EXEC
			    from the max protection when PROT_WRITE
			    is requested. When PROT_EXEC is
			    requested, PROT_WRITE is dropped from the
			    max protection. When both are requested,
			    PROT_WRITE is given priority and
			    PROT_EXEC is dropped from both the
			    request and the max protection.
			</para>
		</sect2>
		<sect2>
			<title>MPROTECT</title>
			<para>If an application requests that a
			    writable mapping be changed to executable
			    via &man.mprotect.2;, the request will
			    fail and set errno to EPERM. The same
			    applies to an executable mapping being
			    changed to writable via &man.mprotect.2;.
			    Applications and shared objects that
			    utilize text relocations (TEXTRELs) have
			    issues with the MPROTECT feature.
			    TEXTRELs require that executable code be
			    relocated to different locations in
			    memory. During the relocation process,
			    the newly allocated memory needs to be
			    both writable and executable. Once the
			    relocation process is finished, the
			    mapping can be marked as
			    PROT_READ|PROT_EXEC.
			</para>
			<para>Some applications with a JIT, most
			    notably Firefox, opt to create writable
			    memory mappings that are non-executable,
			    but upgrade the mapping to executable
			    when appropriate. This gets rid of the
			    problem of having active memory mappings
			    that are both writable and executable.
			    This makes applications like Firefox work
			    with PAGEEXEC, but still have an issue
			    with MPROTECT.
			</para>
		</sect2>
		<sect2>
			<title>Conclusion</title>
			<para>By combining both PAGEEXEC and
			    MPROTECT, HardenedBSD enables a strict
			    form of W^X. Some applications may have
			    issues with PAGEEXEC, MPROTECT, or both.
			    When issues arise, secadm can be used to
			    disable either one or both for just that
			    one application.
			</para>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-secadm">
		<title>Security Administration (secadm)</title>
		<sect2>
			<title>Introduction</title>
			<para>secadm is a tool, distributed via ports,
			    that allows users to toggle exploit
			    mitigations on a per-application and
			    per-jail basis. Users will typically use
			    secadm to disable PAGEEXEC and/or
			    MPROTECT restrictions.
			</para>
			<para>secadm also includes a feature known as
			    Integriforce. Integriforce is an
			    implementation of verified execution. It
			    enforces hash-based signatures for
			    binaries and their dependent shared
			    objects. Integriforce can be set in
			    whitelisting mode. When there is at least
			    one Integriforce rule enabled, all
			    desired applications and their dependent
			    shared objects must also have rules. If
			    an application and its shared objects are
			    not included in the ruleset, execution of
			    that application will be disallowed. This
			    also affects shared objects loaded via
			    &man.dlopen.3;.
			</para>
		</sect2>
		<sect2>
			<title>Downloading and Installing secadm</title>
			<para>secadm is not currently part of base,
			    though that is planned in the near
			    future. secadm can be installed either
			    through the package repo:
			    <screen>&prompt.root; <userinput>pkg install secadm-kmod secadm</userinput></screen>
			    or by using HardenedBSD's ports tree:
			    <screen>&prompt.root; <userinput>cd /usr/ports/hardenedbsd/secadm</userinput>
&prompt.root; <userinput>make install clean</userinput>
&prompt.root; <userinput>cd /usr/ports/hardenedbsd/secadm-kmod</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>
			</para>
		</sect2>
		<sect2>
			<title>Configuring secadm</title>
			<para>By default, secadm looks for a config
			    file at <filename>/usr/local/etc/secadm.rules</filename>.
			    For purposes of this documentation, that
			    file will be simply referenced as <filename>secadm.rules</filename>.
			    secadm does not install or manage the
			    <filename>secadm.rules</filename> file.
			    It simply reads the file, if it exists,
			    passing the parsed data to the kernel
			    module. secadm can be configured either
			    via the command-line or
			    <filename>secadm.rules</filename>. Both
			    secadm and <filename>secadm.rules</filename>
			    contain manual pages. Once installed,
			    users can look at the secadm manpage in
			    section 8 and secadm.rules in section 5.
			</para>
			<para><filename>secadm.rules</filename> should
			    be in a format that libucl can parse as
			    secadm uses libucl to parse
			    <filename>secadm.rules</filename>.
			</para>
			<para>An example <filename>secadm.rules</filename>
			    would look like this:
			</para>
			<programlisting>secadm {
	pax {
		path: "/usr/local/lib/firefox/firefox",
		mprotect: false,
	},
	pax {
		path: "/usr/local/lib/firefox/plugin-container",
		mprotect: false,
	},
}</programlisting>
			<para>Once secadm is configured, it can be
			    started via the &man.rc.8; system:
			    <screen>&prompt.root; <userinput>sysrc secadm_enable=YES</userinput>
&prompt.root; <userinput>service secadm start</userinput></screen>
			</para>
		</sect2>
	</sect1>
</chapter>
