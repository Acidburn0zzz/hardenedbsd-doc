<?xml version="1.0" encoding="iso-8859-1"?>

<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="hardenedbsd">
	<info>
		<title>HardenedBSD</title>

		<authorgroup>
			<author>
				<personname>
					<firstname>Shawn</firstname>
					<surname>Webb</surname>
				</personname>
				<contrib>Written by </contrib>
			</author>
		</authorgroup>
	</info>

	<sect1 xml:id="hardenedbsd-synopsis">
		<title>Synopsis</title>
		<indexterm>
			<primary>HardenedBSD</primary>
		</indexterm>

		<para>HardenedBSD is a fork of FreeBSD, founded
		    in 2014, that implements exploit mitigations and
		    security hardening technologies. The primary goal
		    of HardenedBSD is to port over the grsecurity
		    patchset for Linux to HardenedBSD. HardenedBSD
		    takes a defense-in-depth approach to security,
		    implementing many security hardening technologies
		    out-of-the-box.
		</para>
		<para>Some of HardenedBSD's features can be toggled
		    on a per-application and per-jail basis using
		    a tool called secadm. Documentation for secadm
		    will be covered in this chapter.
		</para>
	</sect1>

	<sect1 xml:id="hardenedbsd-history">
		<title>History</title>
		<para>Work on HardenedBSD began in 2013 when Oliver
		    Pinter and Shawn Webb started working on an
		    implementation of Address Space Layout
		    Randomization (ASLR) for FreeBSD. At that time,
		    HardenedBSD was meant to be a staging area for
		    experimental development on the ASLR patch. Over
		    time, as the process of upstreaming ASLR to
		    FreeBSD became more difficult, HardenedBSD
		    naturally became a fork.
		</para>
		<para>HardenedBSD completed its ASLR implementation
		    in 2015 with the strongest form of ASLR ever
		    implemented in any of the BSDs. Since then,
		    HardenedBSD has moved on to implementing other
		    exploit mitigations and hardening technologies.
		    OPNsense, an open source firewall based on
		    FreeBSD, incorporated HardenedBSD's ASLR
		    implementation in 2016.
		</para>
		<para>HardenedBSD exists today as a fork of FreeBSD
		    that closely follows FreeBSD's source code.
		    HardenedBSD syncs with FreeBSD every six hours
		    for the following FreeBSD branches:
		</para>
		<itemizedlist>
			<listitem><para>HEAD</para></listitem>
			<listitem><para>stable/11</para></listitem>
			<listitem><para>releng/11.0</para></listitem>
			<listitem><para>stable/10</para></listitem>
		</itemizedlist>
	</sect1>
	<sect1 xml:id="hardenedbsd-features">
		<title>Features</title>
		<para>HardenedBSD has successfully implemented the
		    following features:
		</para>
		<itemizedlist>
			<listitem>
				<para>PaX-inspired Address Space
				    Layout Randomization (ASLR)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled as
				    Position-Independent Executables
				    (PIEs)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled with full RELRO
				    (RELRO + BIND_NOW)
				    </para>
			</listitem>
			<listitem>
				<para>PaX-inspired NOEXEC</para>
			</listitem>
			<listitem>
				<para>PaX-inspired PAGEEXEC</para>
			</listitem>
			<listitem>
				<para>PaX-inspired ASLR bruteforce
				    protection (SEGVGUARD)
				</para>
			</listitem>
			<listitem>
				<para>Hardening of certain sensitive
				    sysctl nodes
				</para>
			</listitem>
			<listitem>
				<para>Network stack hardening</para>
			</listitem>
			<listitem>
				<para>Executable file integrity
				    enforcement</para>
			</listitem>
			<listitem>
				<para>Hardening of the boot process
				    </para>
			</listitem>
			<listitem>
				<para>procfs/linprocfs hardening</para>
			</listitem>
			<listitem>
				<para>LibreSSL as the default crypto
				    library in base</para>
			</listitem>
			<listitem>
				<para>Trusted Path Execution (TPE)</para>
			</listitem>
			<listitem>
				<para>Randomized PIDs</para>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="hardenedbsd-aslr">
		<title>Address Space Layout Randomization (ASLR)</title>
		<sect2>
			<title>Introduction</title>
			<para>ASLR randomizes the virtual address
			    space of a process through using
			    randomized deltas. ASLR prevents
			    attackers from knowing where
			    vulnerabilities lie in memory. Without
			    ASLR, attackers can easily generate and
			    reuse exploits across all deployed
			    systems. As is the case with all exploit
			    mitigation technologies, ASLR is meant
			    to help frustrate attackers, though ASLR
			    alone is not sufficient to completely
			    stop attacks. ASLR simply provides a
			    solid foundation in which to implement
			    further exploit mitigation technologies.
			    A holistic approach to security (aka,
			    defense-in-depth) is the best way to
			    secure a system. Additionally, ASLR is
			    intended and designed to help prevent
			    remote attacks, not local.
			</para>
			<para>HardenedBSD's ASLR implementation is
			    based off of PaX's design and
			    documentation. PaX's documentation can be
			    found
			    <link xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/aslr.txt">
			        here</link>.
			    Work on HardenedBSD's ASLR started in
			    2013 when Oliver Pinter and Shawn Webb
			    teamed up to implement it. Oliver had the
			    start of an existing patch and Shawn Webb
			    enhanced it by adding per-jail support and
			    Position-Independent Executable (PIE) base
			    randomization.
			</para>
			<para>On 13 July 2015, HardenedBSD's ASLR
			    implementation was completed with full
			    stack and VDSO randomization. Since then,
			    various improvements have been made, like
			    implementing shared library load order
			    randomization. HardenedBSD is the only
			    BSD to support true stack randomization.
			    Meaning, the top of the stack is
			    randomized in addition to a random-sized
			    gap between the top of the stack and the
			    start of the user stack.
			</para>
			<para>ASLR is enabled by default in the
			    <filename>HARDENEDBSD</filename> kernel
			    configuration. ASLR has been tested and
			    known to work on amd64, i386, arm, arm64,
			    and risc-v. The options for ASLR are:
			    <programlisting>options	PAX
options	PAX_ASLR</programlisting>
			</para>
			<para>If the kernel has been compiled with
			    <programlisting>options	PAX_SYSCTLS</programlisting>
			    then the sysctl node security.hardening.pax.aslr.status
			    will be available. The following values
			    determine the enforcement of ASLR:
			</para>
			<itemizedlist>
				<listitem><para>0 - Force disabled
				    </para></listitem>
				<listitem><para>1 - Disabled by
				    default. User must opt
				    applications in.</para>
				</listitem>
				<listitem><para>2 - Enabled by
				    default. User must opt
				    applications out.</para>
			    	</listitem>
				<listitem><para>3 - Force enabled
				    </para></listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Implementation</title>
			<para>HardenedBSD's ASLR uses a set of four
			    deltas on 32-bit systems and five deltas
			    on 64-bit systems. Additionally, on
			    64-bit systems, 32-bit compatibility is
			    supported by a set of different deltas.
			    The deltas are calculated at image
			    activation (execve) time. The deltas are
			    provided as a hint to the virtual memory
			    subsystem, which may further modify the
			    hint. Such may be the case if the
			    application explicitly requests superpage
			    support or other alignment constraints.
			</para>
			<para>The deltas are:</para>
			<itemizedlist>
				<listitem><para>PIE execution base
				    </para></listitem>
				<listitem><para>mmap hint for
				    non-fixed mappings</para>
				</listitem>
				<listitem><para>stack top and gap
				    </para></listitem>
				<listitem><para>Virtual Dynamic
				    Shared Object (VDSO)</para>
				</listitem>
				<listitem><para>on 64-bit systems,
				    mmap hint for MAP_32BIT mappings
				    </para></listitem>
			</itemizedlist>
			<para> The calculation of each delta is
			    controlled by how many bits of entropy
			    the user wants to introduce into the
			    delta. The amount of entropy can be
			    overridden in the kernel config and
			    via boot-time (loader.conf) tunables. By
			    default, HardenedBSD uses the following
			    amount of entropy:
			</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="8">
					<thead>
						<row>
							<entry>Delta</entry>
							<entry>32-bit</entry>
							<entry>64-bit</entry>
							<entry>Compat</entry>
							<entry>Tunable</entry>
							<entry>Compat Tunable</entry>
							<entry>Kernel Option</entry>
							<entry>Compat Kernel Option</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>mmap</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.mmap_len</entry>
							<entry>hardening.pax.aslr.compat.mmap_len</entry>
							<entry>PAX_ASLR_DELTA_MMAP_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_MMAP_DEF_LEN</entry>
						</row>
						<row>
							<entry>Stack</entry>
							<entry>14 bits</entry>
							<entry>42 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.stack_len</entry>
							<entry>hardening.pax.aslr.compat.stack_len</entry>
							<entry>PAX_ASLR_DELTA_STACK_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_STACK_DEF_LEN</entry>
						</row>
						<row>
							<entry>PIE exec base</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.exec_len</entry>
							<entry>hardening.pax.aslr.compat.exec_len</entry>
							<entry>PAX_ASLR_DELTA_EXEC_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_EXEC_DEF_LEN</entry>
						</row>
						<row>
							<entry>VDSO</entry>
							<entry>8 bits</entry>
							<entry>28 bits</entry>
							<entry>8 bits</entry>
							<entry>hardening.pax.aslr.vdso_len</entry>
							<entry>hardening.pax.aslr.compat.vdso_len</entry>
							<entry>PAX_ASLR_DELTA_VDSO_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_VDSO_DEF_LEN</entry>
						</row>
						<row>
							<entry>MAP_32BIT</entry>
							<entry>N/A</entry>
							<entry>18 bits</entry>
							<entry>N/A</entry>
							<entry>hardening.pax.aslr.map32bit_len</entry>
							<entry>N/A</entry>
							<entry>PAX_ASLR_DELTA_MAP32BIT_DEF_LEN</entry>
							<entry>N/A</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>When a process forks, the child process
			    inherits its parent's ASLR settings,
			    including deltas. Only at image
			    activation (execve) time does a process
			    receive new deltas.
			</para>
		</sect2>
		<sect2>
			<title>Position-Independent Executables (PIEs)</title>
			<para>In order to make full use of ASLR,
			    applications must be compiled as
			    Position-Independent Executables. If an
			    application is not compiled as a PIE,
			    then ASLR will be applied to all but the
			    execution base.  All of base is compiled
			    as PIEs, with the exception of a few
			    applications that explicitly request to
			    be statically compiled. Those
			    applications are:
			</para>
			<itemizedlist>
				<listitem><para>All applications in
				    /rescue</para></listitem>
				<listitem><para>/sbin/devd</para>
				</listitem>
				<listitem><para>/sbin/init</para>
				</listitem>
				<listitem><para>/usr/sbin/nologin</para>
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Shared Library Load Order Randomization</title>
			<para>Breaking ASLR remotely requires
			    multiple vulnerabilities, including one
			    or more information leakage
			    vulnerabilities. Information leakage
			    vulnerabilities expose data an attacker
			    can use to determine the memory layout
			    of the process. Code reuse attacks, like
			    ROP and its variants, exist to attack
			    exploit mitigations like PAGEEXEC/NOEXEC.
			    Over the years, a lot of tooling for
			    automated ROP gadget generation has been
			    developed. The tools generally rely on
			    gadgets found via shared libraries and
			    require that those shared libraries be
			    loaded in the same order. By randomizing
			    the order in which shared libraries get
			    loaded, ROP gadgets have a higher chance
			    of failing. Shared library load order
			    randomization is disabled by default, but
			    can be opted in on a per-application
			    basis using secadm.
			</para>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-wxorx">
		<title>PAGEEXEC and MPROECT</title>
		<sect2>
			<title>Introduction</title>
			<para>PAGEEXEC and MPROTECT comprise what
			    is more commonly called W^X (W xor X).
			    The design and implementation is inspired
			    by PaX's. PAGEEXEC prevents applications
			    from creating memory mappings that are
			    both writable (W) and executable (X) at
			    &man.mmap.2; time. MPROTECT prevents
			    applications from toggling memory
			    mappings between writable and executable
			    with &man.mprotect.2;. Combining both
			    PAGEEXEC and MPROTECT prevents attackers
			    from executing injected code, thus
			    forcing attackers to utilize code reuse
			    techniques like ROP and its variants.
			    Code reuse techniques are very difficult
			    to make reliable, especially when
			    multiple exploit mitigation technologies
			    are present and active.
			</para>
			<para>PaX's documentation for these features:
				<itemizedlist>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/pageexec.txt">
					    PAGEEXEC</link></para>
			    		</listitem>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/mprotect.txt">
					    MPROTECT</link></para>
			    		</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2>
			<title>PAGEEXEC</title>
			<para>If an application requests a memory
			    mapping via &man.mmap.2;, and the
			    application requests PROT_WRITE and
			    PROT_EXEC, then PROT_EXEC is dropped.
			    The application will be able to write to
			    the memory, but not execute what was
			    written. When an application requests W|X
			    mappings, the application is more likely
			    to simply write to the mapping, but not
			    execute it. Such is the case with certain
			    Python scripts: the developer is simply
			    asking for more permissions than is truly
			    needed.
			</para>
			<para>The kernel keeps a concept of max
			    protection. HardenedBSD drops PROT_EXEC
			    from the max protection when PROT_WRITE
			    is requested. When PROT_EXEC is
			    requested, PROT_WRITE is dropped from the
			    max protection. When both are requested,
			    PROT_WRITE is given priority and
			    PROT_EXEC is dropped from both the
			    request and the max protection.
			</para>
		</sect2>
		<sect2>
			<title>MPROTECT</title>
			<para>If an application requests that a
			    writable mapping be changed to executable
			    via &man.mprotect.2;, the request will
			    fail and set errno to EPERM. The same
			    applies to an executable mapping being
			    changed to writable via &man.mprotect.2;.
			    Applications and shared objects that
			    utilize text relocations (TEXTRELs) have
			    issues with the MPROTECT feature.
			    TEXTRELs require that executable code be
			    relocated to different locations in
			    memory. During the relocation process,
			    the newly allocated memory needs to be
			    both writable and executable. Once the
			    relocation process is finished, the
			    mapping can be marked as
			    PROT_READ|PROT_EXEC.
			</para>
			<para>Some applications with a JIT, most
			    notably Firefox, opt to create writable
			    memory mappings that are non-executable,
			    but upgrade the mapping to executable
			    when appropriate. This gets rid of the
			    problem of having active memory mappings
			    that are both writable and executable.
			    This makes applications like Firefox work
			    with PAGEEXEC, but still have an issue
			    with MPROTECT.
			</para>
		</sect2>
		<sect2>
			<title>Conclusion</title>
			<para>By combining both PAGEEXEC and
			    MPROTECT, HardenedBSD enables a strict
			    form of W^X. Some applications may have
			    issues with PAGEEXEC, MPROTECT, or both.
			    When issues arise, secadm can be used to
			    disable either one or both for just that
			    one application.
			</para>
		</sect2>
	</sect1>
</chapter>
