<?xml version="1.0" encoding="iso-8859-1"?>

<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="hardenedbsd">
	<info>
		<title>HardenedBSD</title>

		<authorgroup>
			<author>
				<personname>
					<firstname>Shawn</firstname>
					<surname>Webb</surname>
				</personname>
				<contrib>Written by </contrib>
			</author>
		</authorgroup>
	</info>

	<sect1 xml:id="hardenedbsd-synopsis">
		<title>Synopsis</title>
		<indexterm>
			<primary>HardenedBSD</primary>
		</indexterm>

		<para>HardenedBSD is a fork of FreeBSD, founded
		    in 2014, that implements exploit mitigations and
		    security hardening technologies. The primary goal
		    of HardenedBSD is to perform a clean-room
		    reimplementation of the grsecurity patchset for
		    Linux to HardenedBSD. HardenedBSD takes a
		    defense-in-depth approach to security, implementing
		    many security hardening technologies out-of-the-box.
		</para>
		<para>Some of HardenedBSD's features can be toggled
		    on a per-application and per-jail basis using
		    a tool called secadm. Documentation for secadm
		    will be covered in this chapter.
		</para>
	</sect1>

	<sect1 xml:id="hardenedbsd-history">
		<title>History</title>
		<para>Work on HardenedBSD began in 2013 when Oliver
		    Pinter and Shawn Webb started working on an
		    implementation of Address Space Layout
		    Randomization (ASLR) for FreeBSD. At that time,
		    HardenedBSD was meant to be a staging area for
		    experimental development on the ASLR patch. Over
		    time, as the process of upstreaming ASLR to
		    FreeBSD became more difficult, HardenedBSD
		    naturally became a fork.
		</para>
		<para>HardenedBSD completed its ASLR implementation
		    in 2015 with the strongest form of ASLR ever
		    implemented in any of the BSDs. Since then,
		    HardenedBSD has moved on to implementing other
		    exploit mitigations and hardening technologies.
		    OPNsense, an open source firewall based on
		    FreeBSD, incorporated HardenedBSD's ASLR
		    implementation in 2016.
		</para>
		<para>HardenedBSD exists today as a fork of FreeBSD
		    that closely follows FreeBSD's source code.
		    HardenedBSD syncs with FreeBSD every six hours
		    for the following FreeBSD branches:
		</para>
		<itemizedlist>
			<listitem><para>HEAD</para></listitem>
			<listitem><para>stable/11</para></listitem>
			<listitem><para>releng/11.0</para></listitem>
			<listitem><para>stable/10</para></listitem>
		</itemizedlist>
	</sect1>
	<sect1 xml:id="hardenedbsd-features">
		<title>Features</title>
		<para>HardenedBSD has successfully implemented the
		    following features:
		</para>
		<itemizedlist>
			<listitem>
				<para>PaX-inspired Address Space
				    Layout Randomization (ASLR)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled as
				    Position-Independent Executables
				    (PIEs)
				</para>
			</listitem>
			<listitem>
				<para>Base compiled with full RELRO
				    (RELRO + BIND_NOW)
				    </para>
			</listitem>
			<listitem>
				<para>PaX-inspired NOEXEC</para>
			</listitem>
			<listitem>
				<para>PaX-inspired ASLR bruteforce
				    protection (SEGVGUARD)
				</para>
			</listitem>
			<listitem>
				<para>Hardening of certain sensitive
				    sysctl nodes
				</para>
			</listitem>
			<listitem>
				<para>Network stack hardening</para>
			</listitem>
			<listitem>
				<para>Executable file integrity
				    enforcement</para>
			</listitem>
			<listitem>
				<para>Hardening of the boot process
				    </para>
			</listitem>
			<listitem>
				<para>procfs/linprocfs hardening</para>
			</listitem>
			<listitem>
				<para>LibreSSL as an optional crypto
				    library in base</para>
			</listitem>
			<listitem>
				<para>Trusted Path Execution (TPE)</para>
			</listitem>
			<listitem>
				<para>Randomized PIDs</para>
			</listitem>
			<listitem>
				<para>SafeStack in base</para>
			</listitem>
			<listitem>
				<para>SafeStack available in ports</para>
			</listitem>
			<listitem>
				<para>Non-Cross-DSO CFI</para>
			</listitem>
			<listitem>
				<para>Non-Cross-DSO CFI available in ports</para>
			</listitem>
		</itemizedlist>
	</sect1>
	<sect1 xml:id="hardenedbsd-kernopts">
		<title>Generic Kernel Options</title>
		<para>All of HardenedBSD's features that rely on
		    kernel code require the following kernel option:
		    <programlisting>options	PAX</programlisting>
		    Additionally, the following kernel option is not
		    required, but exposes extra &man.sysctl.8;
		    nodes:
		    <programlisting>options	PAX_SYSCTLS</programlisting>
		</para>
		<para>Generic system hardening can be enabled with
		    the following kernel option:
		    <programlisting>options	PAX_HARDENING</programlisting>
		</para>
	</sect1>
	<sect1 xml:id="hardenedbsd-hardening">
		<title>Generic System Hardening</title>
		<sect2>
			<title>Introduction</title>
			<para>HardenedBSD implements generic system
			    hardening with the PAX_HARDENING kernel
			    option. Many of these hardening features
			    deal with restricting what non-root users
			    are permitted to do. When the kernel is
			    compiled with the PAX_HARDENING kernel
			    option, certain &man.sysctl.8; nodes are
			    modified from their defaults.
			</para>
			<para>&man.procfs.5; and &man.linprocfs.5;
			    are modified to prevent arbitrary writes
			    to a process's registers. This behavior
			    is controlled by the hardening.procfs_harden
			    &man.sysctl.8; node;
			</para>
			<para>&man.kld.4; related system calls are
			    restricted to non-jailed, root-only users.
			    Attempting to list kernel modules using
			    &man.modfind.2;, &man.kldfind.2;, and the
			    other KLD_related system calls will
			    result in permission denied if used by a
			    non-root or jailed user.
			</para>
		</sect2>
		<sect2>
			<title>Modified sysctl Nodes</title>
			<para>These are the nodes that are modified
			    from their original defaults when
			    PAX_HARDENING is enabled in the kernel:
			</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="5">
					<thead>
						<row>
							<entry>Node</entry>
							<entry>Description</entry>
							<entry>Type</entry>
							<entry>Original Value</entry>
							<entry>Hardened Value</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>kern.msgbuf_show_timestamp</entry>
							<entry>Show timestamp in msgbuf</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>kern.randompid</entry>
							<entry>Random PID modulus</entry>
							<entry>Integer</entry>
							<entry>0, read+write</entry>
							<entry>Randomly set at boot and made read-only</entry>
						</row>
						<row>
							<entry>net.inet.ip.random_id</entry>
							<entry>Assign random IP ID values</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.use_deprecated</entry>
							<entry>Allow the use of addresses whose preferred lifetimes have expired</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.use_tempaddr</entry>
							<entry>Use IPv6 temporary addresses with SLAAC</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>net.inet6.ip6.prefer_tempaddr</entry>
							<entry>Prefer IPv6 temporary address generated last</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.see_other_gids</entry>
							<entry>Unprivileged processes may see subjects/objects with different real gid</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.see_other_uids</entry>
							<entry>Unprivileged processes may see subjects/objects with different real uid</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.hardlink_check_gid</entry>
							<entry>Unprivileged processes cannot create hard links to files owned by other groups</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.hardlink_check_uid</entry>
							<entry>Unprivileged processes cannot create hard links to files owned by other users</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.stack_guard_page</entry>
							<entry>Insert stack guard page ahead of the growable segments</entry>
							<entry>Integer</entry>
							<entry>0</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>security.bsd.unprivileged_proc_debug</entry>
							<entry>Unprivileged processes may use process debugging and tracing facilities</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>security.bsd.unprivileged_read_msgbuf</entry>
							<entry>Unprivileged processes may read the kernel message buffer</entry>
							<entry>Integer</entry>
							<entry>1</entry>
							<entry>0</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</sect2>
	</sect1>

	<sect1 xml:id="hardenedbsd-aslr">
		<title>Address Space Layout Randomization (ASLR)</title>
		<sect2>
			<title>Introduction</title>
			<para>ASLR randomizes the virtual address
			    space of a process through using
			    randomized deltas. ASLR prevents
			    attackers from knowing where
			    vulnerabilities lie in memory. Without
			    ASLR, attackers can easily generate and
			    reuse exploits across all deployed
			    systems. As is the case with all exploit
			    mitigation technologies, ASLR is meant
			    to help frustrate attackers, though ASLR
			    alone is not sufficient to completely
			    stop attacks. ASLR simply provides a
			    solid foundation in which to implement
			    further exploit mitigation technologies.
			    A holistic approach to security (aka,
			    defense-in-depth) is the best way to
			    secure a system. Additionally, ASLR is
			    intended and designed to help prevent
			    remote attacks, not local.
			</para>
			<para>HardenedBSD's ASLR implementation is
			    based off of PaX's design and
			    documentation. PaX's documentation can be
			    found
			    <link xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/aslr.txt">
			        here</link>.
			</para>
			<para>On 13 July 2015, HardenedBSD's ASLR
			    implementation was completed with full
			    stack and VDSO randomization. Since then,
			    various improvements have been made, like
			    implementing shared library load order
			    randomization. HardenedBSD is the only
			    BSD to support true stack randomization.
			    Meaning, the top of the stack is
			    randomized in addition to a random-sized
			    gap between the top of the stack and the
			    start of the user stack.
			</para>
			<para>ASLR is enabled by default in the
			    <filename>HARDENEDBSD</filename> kernel
			    configuration. ASLR has been tested and
			    known to work on amd64, i386, arm, arm64,
			    and risc-v. The options for ASLR are:
			    <programlisting>options	PAX
options	PAX_ASLR</programlisting>
			</para>
			<para>If the kernel has been compiled with
			    <programlisting>options	PAX_SYSCTLS</programlisting>
			    then the sysctl node security.hardening.pax.aslr.status
			    will be available. The following values
			    determine the enforcement of ASLR:
			</para>
			<itemizedlist>
				<listitem><para>0 - Force disabled
				    </para></listitem>
				<listitem><para>1 - Disabled by
				    default. User must opt
				    applications in.</para>
				</listitem>
				<listitem><para>2 - Enabled by
				    default. User must opt
				    applications out (default).</para>
			    	</listitem>
				<listitem><para>3 - Force enabled
				    </para></listitem>
			</itemizedlist>
		</sect2>
		<sect2>
			<title>Implementation</title>
			<para>HardenedBSD's ASLR uses a set of four
			    deltas on 32-bit systems and five deltas
			    on 64-bit systems. Additionally, on
			    64-bit systems, 32-bit compatibility is
			    supported by a set of different deltas.
			    The deltas are calculated at image
			    activation (execve) time. The deltas are
			    provided as a hint to the virtual memory
			    subsystem, which may further modify the
			    hint. Such may be the case if the
			    application explicitly requests superpage
			    support or other alignment constraints.
			</para>
			<para>The deltas are:</para>
			<itemizedlist>
				<listitem><para>PIE execution base
				    </para></listitem>
				<listitem><para>mmap hint for
				    non-fixed mappings</para>
				</listitem>
				<listitem><para>stack top and gap
				    </para></listitem>
				<listitem><para>Virtual Dynamic
				    Shared Object (VDSO)</para>
				</listitem>
				<listitem><para>on 64-bit systems,
				    mmap hint for MAP_32BIT mappings
				    </para></listitem>
			</itemizedlist>
			<para> The calculation of each delta is
			    controlled by how many bits of entropy
			    the user wants to introduce into the
			    delta. The amount of entropy can be
			    overridden in the kernel config and
			    via boot-time (loader.conf) tunables. By
			    default, HardenedBSD uses the following
			    amount of entropy:
			</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="8">
					<thead>
						<row>
							<entry>Delta</entry>
							<entry>32-bit</entry>
							<entry>64-bit</entry>
							<entry>Compat</entry>
							<entry>Tunable</entry>
							<entry>Compat Tunable</entry>
							<entry>Kernel Option</entry>
							<entry>Compat Kernel Option</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>mmap</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.mmap_len</entry>
							<entry>hardening.pax.aslr.compat.mmap_len</entry>
							<entry>PAX_ASLR_DELTA_MMAP_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_MMAP_DEF_LEN</entry>
						</row>
						<row>
							<entry>Stack</entry>
							<entry>14 bits</entry>
							<entry>42 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.stack_len</entry>
							<entry>hardening.pax.aslr.compat.stack_len</entry>
							<entry>PAX_ASLR_DELTA_STACK_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_STACK_DEF_LEN</entry>
						</row>
						<row>
							<entry>PIE exec base</entry>
							<entry>14 bits</entry>
							<entry>30 bits</entry>
							<entry>14 bits</entry>
							<entry>hardening.pax.aslr.exec_len</entry>
							<entry>hardening.pax.aslr.compat.exec_len</entry>
							<entry>PAX_ASLR_DELTA_EXEC_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_EXEC_DEF_LEN</entry>
						</row>
						<row>
							<entry>VDSO</entry>
							<entry>8 bits</entry>
							<entry>28 bits</entry>
							<entry>8 bits</entry>
							<entry>hardening.pax.aslr.vdso_len</entry>
							<entry>hardening.pax.aslr.compat.vdso_len</entry>
							<entry>PAX_ASLR_DELTA_VDSO_DEF_LEN</entry>
							<entry>PAX_ASLR_COMPAT_DELTA_VDSO_DEF_LEN</entry>
						</row>
						<row>
							<entry>MAP_32BIT</entry>
							<entry>N/A</entry>
							<entry>18 bits</entry>
							<entry>N/A</entry>
							<entry>hardening.pax.aslr.map32bit_len</entry>
							<entry>N/A</entry>
							<entry>PAX_ASLR_DELTA_MAP32BIT_DEF_LEN</entry>
							<entry>N/A</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>When a process forks, the child process
			    inherits its parent's ASLR settings,
			    including deltas. Only at image
			    activation (execve) time does a process
			    receive new deltas.
			</para>
		</sect2>
		<sect2>
			<title>Position-Independent Executables (PIEs)</title>
			<para>In order to make full use of ASLR,
			    applications must be compiled as
			    Position-Independent Executables. If an
			    application is not compiled as a PIE,
			    then ASLR will be applied to all but the
			    execution base.  All of base is compiled
			    as PIEs, with the exception of a few
			    applications that explicitly request to
			    be statically compiled. Those
			    applications are:
			</para>
			<itemizedlist>
				<listitem><para>All applications in
				    /rescue</para></listitem>
				<listitem><para>/sbin/devd</para>
				</listitem>
				<listitem><para>/sbin/init</para>
				</listitem>
				<listitem><para>/usr/sbin/nologin</para>
				</listitem>
			</itemizedlist>
			<para>Compiling all of base as PIEs can be
			    turned off by setting WITHOUT_PIE=yes in
			    &man.src.conf.5;
			</para>
		</sect2>
		<sect2>
			<title>Shared Library Load Order Randomization</title>
			<para>Breaking ASLR remotely requires chaining
			    multiple vulnerabilities, including one
			    or more information leakage
			    vulnerabilities. Information leakage
			    vulnerabilities expose data an attacker
			    can use to determine the memory layout
			    of the process. Code reuse attacks, like
			    ROP and its variants, exist to attack
			    exploit mitigations like PAGEEXEC/NOEXEC.
			    Over the years, a lot of tooling for
			    automated ROP gadget generation has been
			    developed. The tools generally rely on
			    gadgets found via shared libraries and
			    require that those shared libraries be
			    loaded in the same order. By randomizing
			    the order in which shared libraries get
			    loaded, ROP gadgets have a higher chance
			    of failing. Shared library load order
			    randomization is disabled by default, but
			    can be opted in on a per-application
			    basis using secadm.
			</para>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-wxorx">
		<title>PAGEEXEC and MPROTECT (aka, NOEXEC)</title>
		<sect2>
			<title>Introduction</title>
			<para>PAGEEXEC and MPROTECT comprise what
			    is more commonly called W^X (W xor X).
			    The design and implementation is inspired
			    by PaX's. PAGEEXEC prevents applications
			    from creating memory mappings that are
			    both writable (W) and executable (X) at
			    &man.mmap.2; time. MPROTECT prevents
			    applications from toggling memory
			    mappings between writable and executable
			    with &man.mprotect.2;. Combining both
			    PAGEEXEC and MPROTECT prevents attackers
			    from executing injected code, thus
			    forcing attackers to utilize code reuse
			    techniques like ROP and its variants.
			    Code reuse techniques are very difficult
			    to make reliable, especially when
			    multiple exploit mitigation technologies
			    are present and active.
			</para>
			<para>PaX's documentation for these features:
				<itemizedlist>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/pageexec.txt">
					    PAGEEXEC</link></para>
			    		</listitem>
					<listitem><para><link
					    xlink:href="https://github.com/HardenedBSD/pax-docs-mirror/blob/master/mprotect.txt">
					    MPROTECT</link></para>
			    		</listitem>
				</itemizedlist>
			</para>
			<para>The PAGEEXEC and MPROTECT features can
			    be enabled with the following kernel
			    option, which is enabled by default in the
			    <filename>HARDENEDBSD</filename>
			    kernel:
			    <programlisting>options	PAX_NOEXEC</programlisting>
			    If the PAX_SYSCTLS option is also
			    enabled, two new sysctl nodes will be
			    created, which follow the same symantics
			    as the hardening.pax.aslr.status sysctl:
			    <itemizedlist>
				    <listitem>
					<para>hardening.pax.pageexec.status
						<itemizedlist><listitem><para>Default: 2</para></listitem></itemizedlist>
				    	</para></listitem>
				    <listitem>
					<para>hardening.pax.mprotect.status
						<itemizedlist><listitem><para>Default: 2</para></listitem></itemizedlist>
				    	</para></listitem>
			    </itemizedlist>
			</para>
		</sect2>
		<sect2>
			<title>PAGEEXEC</title>
			<para>If an application requests a memory
			    mapping via &man.mmap.2;, and the
			    application requests PROT_WRITE and
			    PROT_EXEC, then PROT_EXEC is dropped.
			    The application will be able to write to
			    the memory, but not execute what was
			    written. When an application requests W|X
			    mappings, the application is more likely
			    to simply write to the mapping, but not
			    execute it. Such is the case with certain
			    Python scripts: the developer is simply
			    asking for more permissions than is truly
			    needed.
			</para>
			<para>The kernel keeps a concept of max
			    protection. HardenedBSD drops PROT_EXEC
			    from the max protection when PROT_WRITE
			    is requested. When PROT_EXEC is
			    requested, PROT_WRITE is dropped from the
			    max protection. When both are requested,
			    PROT_WRITE is given priority and
			    PROT_EXEC is dropped from both the
			    request and the max protection.
			</para>
		</sect2>
		<sect2>
			<title>MPROTECT</title>
			<para>If an application requests that a
			    writable mapping be changed to executable
			    via &man.mprotect.2;, the request will
			    fail and set errno to EPERM. The same
			    applies to an executable mapping being
			    changed to writable via &man.mprotect.2;.
			    Applications and shared objects that
			    utilize text relocations (TEXTRELs) have
			    issues with the MPROTECT feature.
			    TEXTRELs require that executable code be
			    relocated to different locations in
			    memory. During the relocation process,
			    the newly allocated memory needs to be
			    both writable and executable. Once the
			    relocation process is finished, the
			    mapping can be marked as
			    PROT_READ|PROT_EXEC.
			</para>
			<para>Some applications with a JIT, most
			    notably Firefox, opt to create writable
			    memory mappings that are non-executable,
			    but upgrade the mapping to executable
			    when appropriate. This gets rid of the
			    problem of having active memory mappings
			    that are both writable and executable.
			    This makes applications like Firefox work
			    with PAGEEXEC, but still have an issue
			    with MPROTECT.
			</para>
		</sect2>
		<sect2>
			<title>Conclusion</title>
			<para>By combining both PAGEEXEC and
			    MPROTECT, HardenedBSD enables a strict
			    form of W^X. Some applications may have
			    issues with PAGEEXEC, MPROTECT, or both.
			    When issues arise, secadm can be used to
			    disable either one or both for just that
			    one application.
			</para>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-safestack">
		<title>SafeStack</title>
		<para>SafeStack is an exploit mitigation technique
		    that creates two stacks: one for data that needs
		    to be kept safe, such as return addresses and
		    function pointers; and an unsafe stack for
		    everything else. SafeStack promises a low
		    performance penalty (typically around 0.1%).
		</para>
		<para>SafeStack requires both ASLR and W^X in order to
		    be effective. With HardenedBSD satisfying both of
		    those prerequisites, SafeStack was deemed to be
		    an excellent candidate for default inclusion in
		    HardenedBSD. Starting with HardenedBSD 11-STABLE,
		    it is enabled by default for amd64. Support for
		    non-amd64 architectures is limited by upstream
		    clang. SafeStack can be disabled by setting
		    WITHOUT_SAFESTACK in &man.src.conf.5;.
		</para>
		<para>SafeStack only supports being applied to
		    applications and not shared libraries. Multiple
		    patches have been submitted to clang by third
		    parties to add support for shared libraries. As
		    such, SafeStack is still undergoing active
		    development.
		</para>
		<para>SafeStack has been made available to the
		    HardenedBSD ports tree as well. Unlike PIE and
		    RELRO+BIND_NOW, it is not enabled globally for
		    the ports tree. Some ports, like ports-mgmt/pkg,
		    have SafeStack enabled by default. Only those
		    ports that have been tested to work fine will
		    have SafeStack enabled by default. Users are
		    able to toggle SafeStack by using the config
		    target. Additionally, the SafeStack option is
		    only applicable to amd64 architectures.
		    Attempting to enable SafeStack for a non-amd64
		    port build will result in a NO-OP. SafeStack will
		    simply not be applied.
		</para>

	</sect1>
	<sect1 xml:id="hardenedbsd-cfi">
		<title>Control-Flow Integrity</title>
		<para>Control-Flow Integrity (CFI) is an exploit mitigation
		    technique that prevents unwanted transfer of control
		    from branch instructions to arbitrary valid memory
		    locations. The CFI implementation from clang/llvm
		    comes in two forms: Cross-DSO CFI and non-Cross-DSO
		    CFI. HardenedBSD 12-CURRENT enables non-Cross-DSO CFI
		    by default on amd64 and arm64 for base.
		</para>
		<para>CFI requires a linker that supports Link Time
		    Optimization (LTO). Starting with 12-CURRENT,
		    HardenedBSD ships with lld as the default linker. lld
		    supports LTO.
		</para>
		<para>Non-Cross-DSO CFI adds checks both before and after
		    every branch instruction in the application itself.
		    If an application loads libraries via &man.dlopen.3;
		    and resolves functions via &man.dlsym.3; and calls
		    those functions, the application will abort. Some
		    applications, like &man.bhyveload.8; do this and thus
		    have the cfi-icall scheme disabled, allowing it to call
		    the function resolved via &man.dlsym.3;. Thus, if a user
		    finds that an application crashes in HardenedBSD
		    12-CURRENT, the user should file a bug report. The
		    cfi-icall scheme can be disabled when building world by
		    adding a CFI override in that application's Makefile.
		</para>
		<para>Note that Non-Cross-DSO CFI does not require ASLR and
		    strict W^X. Given that Cross-DSO CFI keeps metadata and
		    state information, Cross-DSO CFI does require ASLR and
		    W^X in order to be effective.
		</para>
		<para>Non-Cross-DSO CFI support has been added to HardenedBSD's
		    ports framework. However, it is not enabled by default.
		    Support for CFI in ports is still very premature and is only
		    available for those brave users who want to experiment.
		</para>
		<para>As of 20 May 2017, Cross-DSO CFI is being actively
		    researched. However, support for Cross-DSO CFI is not
		    available in HardenedBSD, yet. Cross-DSO CFI would allow
		    functions resolved through &man.dlopen.3;/&man.dlsym.3;
		    to work since CFI would be able to be applied between
		    Dynamic Shared Object (DSO) boundaries. Signifficant progress
		    has been made in the first half of 2018 with regards to
		    Cross-DSO CFI. The base operating system can be fully
		    compiled with Cross-DSO CFI. On 16 July 2018, a pre-alpha
		    <link xlink:href="https://hardenedbsd.org/article/shawn-webb/2018-07-16/preliminary-call-testing-cross-dso-cfi">Call For Testing (CFT)</link>
		    was released for wider initial testing. The HardenedBSD core
		    development team hopes to launch Cross-DSO CFI in base
		    within the latter half of 2019.
		</para>
	</sect1>
	<sect1 xml:id="hardenedbsd-secadm">
		<title>Security Administration (secadm)</title>
		<sect2>
			<title>Introduction</title>
			<para>secadm is a tool, distributed via ports,
			    that allows users to toggle exploit
			    mitigations on a per-application and
			    per-jail basis. Users will typically use
			    secadm to disable PAGEEXEC and/or
			    MPROTECT restrictions.
			</para>
			<para>secadm also includes a feature known as
			    Integriforce. Integriforce is an
			    implementation of verified execution. It
			    enforces hash-based signatures for
			    binaries and their dependent shared
			    objects. Integriforce can be set in
			    whitelisting mode. When there is at least
			    one Integriforce rule enabled, all
			    desired applications and their dependent
			    shared objects must also have rules. If
			    an application and its shared objects are
			    not included in the ruleset, execution of
			    that application will be disallowed. This
			    also affects shared objects loaded via
			    &man.dlopen.3;.
			</para>
			<para>When a file is added to secadm's ruleset,
			    secadm will disallow modifications to that file.
			    This includes deleting, appending, truncating, or
			    otherwise modifying the file. This is because
			    secadm tracks files under its control by using the
			    inode. Modifying the file might change the inode,
			    or freeing it in case of deletion, thereby implicitly
			    modifying the secadm ruleset. To protect the integrity
			    of the loaded ruleset, secadm also protects the files
			    it controls.
		    	</para>
			<para>Thus, when updating installed ports or packages,
			    care must be taken. Flush the ruleset prior to
			    installing updates. The ruleset can be reloaded after
			    updating.
			</para>
		</sect2>
		<sect2>
			<title>Downloading and Installing secadm</title>
			<para>secadm is not currently part of base,
			    though that is planned in the near
			    future. secadm can be installed either
			    through the package repo:
			    <screen>&prompt.root; <userinput>pkg install secadm-kmod secadm</userinput></screen>
			    or by using HardenedBSD's ports tree:
			    <screen>&prompt.root; <userinput>cd /usr/ports/hardenedbsd/secadm</userinput>
&prompt.root; <userinput>make install clean</userinput>
&prompt.root; <userinput>cd /usr/ports/hardenedbsd/secadm-kmod</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>
			</para>
		</sect2>
		<sect2>
			<title>Configuring secadm</title>
			<para>By default, secadm looks for a config
			    file at <filename>/usr/local/etc/secadm.rules</filename>.
			    For purposes of this documentation, that
			    file will be simply referenced as <filename>secadm.rules</filename>.
			    secadm does not install or manage the
			    <filename>secadm.rules</filename> file.
			    It simply reads the file, if it exists,
			    passing the parsed data to the kernel
			    module. secadm can be configured either
			    via the command-line or
			    <filename>secadm.rules</filename>. Both
			    secadm and <filename>secadm.rules</filename>
			    contain manual pages. Once installed,
			    users can look at the secadm manpage in
			    section 8 and secadm.rules in section 5.
			</para>
			<para><filename>secadm.rules</filename> should
			    be in a format that libucl can parse as
			    secadm uses libucl to parse
			    <filename>secadm.rules</filename>.
			</para>
			<para>An example <filename>secadm.rules</filename>
			    would look like this:
			</para>
			<programlisting>secadm {
	pax {
		path: "/usr/local/lib/firefox/firefox",
		mprotect: false,
	},
	pax {
		path: "/usr/local/lib/firefox/plugin-container",
		mprotect: false,
	},
}</programlisting>
			<para>Once secadm is configured, it can be
			    started via the &man.rc.8; system:
			    <screen>&prompt.root; <userinput>sysrc secadm_enable=YES</userinput>
&prompt.root; <userinput>service secadm start</userinput></screen>
			</para>
		</sect2>
		<sect2>
			<title>All secadm configuration options</title>
			<para>These are the available pax options:</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="4">
					<thead>
						<row>
							<entry>Option</entry>
							<entry>Requirement</entry>
							<entry>Type</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>path</entry>
							<entry>Required</entry>
							<entry>String</entry>
							<entry>Fully-qualified path of the executable</entry>
						</row>
						<row>
							<entry>aslr</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle ASLR</entry>
						</row>
						<row>
							<entry>disallow_map32bit</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle the ability to use the MAP_32BIT &man.mmap.2; flag on 64-bit systems</entry>
						</row>
						<row>
							<entry>mprotect</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle mprotect restrictions</entry>
						</row>
						<row>
							<entry>pageexec</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle pageexec restrictions</entry>
						</row>
						<row>
							<entry>segvguard</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle SEGVGUARD</entry>
						</row>
						<row>
							<entry>shlibrandom</entry>
							<entry>Optional</entry>
							<entry>Boolean</entry>
							<entry>Toggle shared library load order randomization</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>Example pax configuration:
			</para>
			<programlisting>secadm {
	pax {
		path: "/usr/local/lib/firefox/firefox",
		mprotect: false,
	},
	pax {
		path: "/usr/local/lib/firefox/plugin-container",
		mprotect: false,
	},
}</programlisting>
			<para>These are the available integriforce options:</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="4">
					<thead>
						<row>
							<entry>Option</entry>
							<entry>Requirement</entry>
							<entry>Type</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>path</entry>
							<entry>Required</entry>
							<entry>String</entry>
							<entry>Fully-qualified path of the executable or shared library</entry>
						</row>
						<row>
							<entry>hash</entry>
							<entry>Required</entry>
							<entry>String</entry>
							<entry>&man.sha1.1; or &man.sha256.1; hash of the file</entry>
						</row>
						<row>
							<entry>type</entry>
							<entry>Required</entry>
							<entry>String</entry>
							<entry>Type of hash. Either "sha1" or "sha256".</entry>
						</row>
						<row>
							<entry>mode</entry>
							<entry>Required</entry>
							<entry>String</entry>
							<entry>Either "soft" or "hard". In soft mode, if the hash doesn't match,
							    a warning is printed in syslog and execution is allowed. In hard
							    mode, if the hash doesn't match, an error is printed in syslog and
							    execution is denied.</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>Example integriforce configuration:</para>
			<programlisting>secadm {
	integriforce {
		path: "/bin/ls",
		hash: "7dee472b6138d05b3abcd5ea708ce33c8e85b3aac13df350e5d2b52382c20e77",
		type: "sha256",
		mode: "hard",
	}
}
</programlisting>
			<warning>
				<para>As of 26 Aug 2018, secadm is planned to undergo a major rewrite.
				    Certain features, like TPE, will be merged into HardenedBSD base and
				    removed from the rewrite.</para>
			</warning>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-contributing">
		<title>Contributing to HardenedBSD</title>
		<sect2>
			<title>Submitting Bug Reports</title>
			<para>HardenedBSD uses GitHub for source control and bug reports. Users can
			    submit bug reports for the HardenedBSD base source code
			    <link xlink:href="https://github.com/HardenedBSD/hardenedbsd/issues">here</link>
			    and for ports
			    <link xlink:href="https://github.com/HardenedBSD/hardenedbsd-ports/issues">here</link>.
			    When submitting bug reports, please include the following information:
			    <itemizedlist>
				    <listitem><para>HardenedBSD version</para></listitem>
				    <listitem><para>Architecture</para></listitem>
				    <listitem><para>If the report concerns a kernel panic, the backtrace of the panic</para></listitem>
				    <listitem><para>Steps to reproduce the bug</para></listitem>
			    </itemizedlist>
			</para>
		</sect2>
		<sect2>
			<title>HardenedBSD Development Process</title>
			<para>HardenedBSD uses three repositories during the development process:</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="2">
					<thead>
						<row>
							<entry>Repository</entry>
							<entry>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><link xlink:href="https://github.com/HardenedBSD/hardenedBSD">HardenedBSD</link></entry>
							<entry>Main development repository</entry>
						</row>
						<row>
							<entry><link xlink:href="https://github.com/HardenedBSD/hardenedBSD-stable">HardenedBSD-STABLE</link></entry>
							<entry>Stable builds repository (read-only)</entry>
						</row>
						<row>
							<entry><link xlink:href="https://github.com/HardenedBSD/hardenedBSD-playground">HardenedBSD-Playground</link></entry>
							<entry>Highly experimental and third-party code repository</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para>HardenedBSD development branches:</para>
			<informaltable frame="all" pgwide="0">
				<tgroup cols="4">
					<thead>
						<row>
							<entry>Branch</entry>
							<entry>Repository</entry>
							<entry>Binary Updates</entry>
							<entry>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>hardened/current/master</entry>
							<entry>HardenedBSD</entry>
							<entry>amd64, arm64</entry>
							<entry>Main development branch (12-CURRENT)</entry>
						</row>
						<row>
							<entry>hardened/11-stable/master</entry>
							<entry>HardenedBSD</entry>
							<entry>amd64</entry>
							<entry>11-STABLE development</entry>
						</row>
						<row>
							<entry>hardened/10-stable/master</entry>
							<entry>HardenedBSD</entry>
							<entry>amd64</entry>
							<entry>10-STABLE development</entry>
						</row>
						<row>
							<entry>hardened/current/drm-next</entry>
							<entry>HardenedBSD-Playground</entry>
							<entry>amd64</entry>
							<entry>HardenedBSD 12-CURRENT with drm-next bits merged in</entry>
						</row>
						<row>
							<entry>hardened/current/safestack-arm64</entry>
							<entry>HardenedBSD-Playground</entry>
							<entry>arm64</entry>
							<entry>HardenedBSD 12-CURRENT with SafeStack ported to arm64</entry>
						</row>
						<row>
							<entry>hardened/current/cross-dso-cfi</entry>
							<entry>HardenedBSD-Playground</entry>
							<entry>N/A</entry>
							<entry>HardenedBSD 12-CURRENT with Cross-DSO-CFI support</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</sect2>
	</sect1>
	<sect1 xml:id="hardenedbsd-updating">
		<title>Updating HardenedBSD</title>
		<sect2>
			<title>Updating the Base Operating System</title>
			<para>HardenedBSD does not use &man.freebsd-update.8;. Instead, HardenedBSD
			    uses an utility known as hbsd-update. hbsd-update does not use deltas for
			    publishing updates, but rather distributes the base operating system as a
			    whole. Not utilizing deltas incurs a bandwidth overhead, but is easier to
			    maintain and mirror. hbsd-update relies on DNSSEC-signed TXT records for
			    distributing version information.</para>
			<para>hbsd-update is configured via a config file placed at
			    <filename>/etc/hbsd-update.conf</filename>. hbsd-update works on a branch
			    level, meaning it tracks branches within HardenedBSD's source tree. Thus,
			    updating from one major version to another requires changing the dnsrec
			    and branch variables in <filename>hbsd-update.conf</filename>. For example,
			    the <filename>hbsd-update.conf</filename> for the hardened/current/master
			    branch in the HardenedBSD repo:</para>
		    	<programlisting>dnsrec="$(uname -m).master.current.hardened.hardenedbsd.updates.hardenedbsd.org"
capath="/usr/share/keys/hbsd-update/trusted"
branch="hardened/current/master"
baseurl="http://updates.hardenedbsd.org/pub/HardenedBSD/updates/${branch}/$(uname -m)"
</programlisting>
			<para>And as another example, the <filename>hbsd-update.conf</filename>
			    for the hardened/11-stable/master branch in the HardenedBSD repo:</para>
		    	<programlisting>dnsrec="$(uname -m).master.11-stable.hardened.hardenedbsd.updates.hardenedbsd.org"
capath="/usr/share/keys/hbsd-update/trusted"
branch="hardened/11-stable/master"
baseurl="http://updates.hardenedbsd.org/pub/HardenedBSD/updates/${branch}/$(uname -m)"
</programlisting>
			<para>Thus, generating a diff between the two configuration files would
			    result in:</para>
		    	<programlisting>--- hbsd-update_current.conf	2017-07-21 20:08:22.153616000 -0400
+++ hbsd-update_11-stable.conf	2017-07-21 20:08:38.003508000 -0400
@@ -1,4 +1,4 @@
-dnsrec="$(uname -m).master.current.hardened.hardenedbsd.updates.hardenedbsd.org"
+dnsrec="$(uname -m).master.11-stable.hardened.hardenedbsd.updates.hardenedbsd.org"
 capath="/usr/share/keys/hbsd-update/trusted"
-branch="hardened/current/master"
+branch="hardened/11-stable/master"
 baseurl="http://updates.hardenedbsd.org/pub/HardenedBSD/updates/${branch}/$(uname -m)"
 </programlisting>
 		<warning>
			<para>Official updates from HardenedBSD for the -CURRENET branch come from
			    the main development repository, not from the stable builds repository.
			    Official updates for -STABLE branches from from the HardenedBSD-STABLE
			    repository.
			</para>
		</warning>
		</sect2>
	</sect1>
</chapter>
